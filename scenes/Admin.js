const Markup = require('telegraf/markup')
const Extra = require('telegraf/extra')
const Scene = require('telegraf/scenes/base')
const { match } = require('telegraf-i18n')
const fileNameAnswers = '../data/answers.json'
const answers =  require(fileNameAnswers)
const fs = require('fs');

const docsFileName = '../data/documents.json'
let docs = require(docsFileName)

let message
let block = false
let stack = []

const keyboard = 
    [
        [Markup.callbackButton('‚ùî FAQ', '‚ùî FAQ'), Markup.callbackButton('üì¢ –û—Ç—á–µ—Ç—ã', 'üì¢ –û—Ç—á–µ—Ç—ã')],
        [Markup.callbackButton('üîµ –£—Å–ª—É–≥–∏', 'üîµ –£—Å–ª—É–≥–∏'), Markup.callbackButton('üü¢ –¢–æ–≤–∞—Ä—ã', 'üü¢ –¢–æ–≤–∞—Ä—ã')]
    ]


const keyboard1 = 
    [
        [Markup.callbackButton('‚ûï–î–æ–±–∞–≤–∏—Ç—å –≤–æ–ø—Ä–æ—Å', 'add'), Markup.callbackButton('‚úñÔ∏è–£–¥–∞–ª–∏—Ç—å –≤–æ–ø—Ä–æ—Å', 'del')]
        ,[Markup.callbackButton('–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å', 'show'), Markup.callbackButton('–®–∞–≥ –Ω–∞–∑–∞–¥', 'back')]
    ]


const keyboard2 = 
    [
        [Markup.callbackButton('‚ûï–î–æ–±–∞–≤–∏—Ç—å –æ—Ç—á–µ—Ç', 'add'),Markup.callbackButton('‚úñÔ∏è–£–¥–∞–ª–∏—Ç—å –æ—Ç—á–µ—Ç', 'del')]
        ,[Markup.callbackButton('–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å', 'show'), Markup.callbackButton('–®–∞–≥ –Ω–∞–∑–∞–¥', 'back')]
    ]


const keyboard3 = 
    [
        [Markup.callbackButton('‚ûï–î–æ–±–∞–≤–∏—Ç—å —É—Å–ª—É–≥—É', 'add'), Markup.callbackButton('‚úñÔ∏è–£–¥–∞–ª–∏—Ç—å —É—Å–ª—É–≥—É', 'del')],
        [Markup.callbackButton('–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å', 'show')],[Markup.callbackButton('üõ† –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å', 'red'), Markup.callbackButton('–®–∞–≥ –Ω–∞–∑–∞–¥', 'back')]
    ]


const keyboard4 = 
    [
        [Markup.callbackButton('‚ûï–î–æ–±–∞–≤–∏—Ç—å —Ç–æ–≤–∞—Ä', 'add'), Markup.callbackButton('‚úñÔ∏è–£–¥–∞–ª–∏—Ç—å —Ç–æ–≤–∞—Ä', 'del')],
        [Markup.callbackButton('–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å', 'show')], [Markup.callbackButton('üõ† –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å', 'red'), Markup.callbackButton('–®–∞–≥ –Ω–∞–∑–∞–¥', 'back')]
    ]


dict = {
    "‚ùî FAQ": keyboard1,
    "üì¢ –û—Ç—á–µ—Ç—ã": keyboard2,
    "üîµ –£—Å–ª—É–≥–∏": keyboard3,
    "üü¢ –¢–æ–≤–∞—Ä—ã": keyboard4
}

dictList = {
    "‚ùî FAQ": listFAQ,
    "üì¢ –û—Ç—á–µ—Ç—ã": listReports,
    "üîµ –£—Å–ª—É–≥–∏": emptyList,
    "üü¢ –¢–æ–≤–∞—Ä—ã": emptyList
}

dictAdd = {
    "‚ùî FAQ": addFAQ,
    "üì¢ –û—Ç—á–µ—Ç—ã": addReport,
    "üîµ –£—Å–ª—É–≥–∏": empty,
    "üü¢ –¢–æ–≤–∞—Ä—ã": empty
}

async function emptyList(){
    return []
}

async function empty(){
    return null
}

let step = 0// —Ç—É—Ç
let timeout
class SceneGenerator{

    admin() {
        const item = new Scene('admin')

        item.enter(async ctx => {
            await ctx.replyWithHTML(`<b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —Ä–µ–∂–∏–º –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞!</b> –ß—Ç–æ–±—ã –≤–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é, –≤–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π...`, 
            Extra.HTML({parse_mode: 'HTML'})
            .markup(Markup.keyboard(
                [[`üìö –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é`]]).resize()))
            block = false
            const scem = {text: `–ß—Ç–æ –≤—ã —Ö–æ—Ç–µ–ª–∏ –±—ã –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å?`, keyboard: keyboard}
            ctx.webhookReply = false
            message = await ctx.replyWithHTML(scem.text, Extra.HTML().markup(Markup.inlineKeyboard(scem.keyboard)))
            ctx.webhookReply = true
            stack.push(scem)
            updateTimeout(ctx)
        })

        item.action(/üü¢|üîµ|üì¢|‚ùî/, async ctx => {  // –±—É–∫–≤—ã - –Ω–µ—Ç
            try{
                if (ctx.update.callback_query.message.message_id === message.message_id){
                const text = ctx.callbackQuery.data
                await ctx.telegram.deleteMessage(message.chat.id, message.message_id) // –≤ —Ñ—É–Ω–∫—Ü
                const scem = { text: text, keyboard: dict[text]}
                ctx.webhookReply = false
                message = await ctx.replyWithHTML(scem.text, Extra.HTML().markup(Markup.inlineKeyboard(scem.keyboard)))
                ctx.webhookReply = true
                stack.push(scem)
                updateTimeout(ctx)
            }}catch(e){console.log(e)}
        })

        item.action('back', async ctx => {
            try{
                if (ctx.update.callback_query.message.message_id === message.message_id){
                    try{
                        await ctx.telegram.deleteMessage(message.chat.id, message.message_id)
                        stack.pop()
                        const scem = stack[stack.length - 1]
                        ctx.webhookReply = false
                        message = await ctx.replyWithHTML(scem.text, Extra.HTML().markup(Markup.inlineKeyboard(scem.keyboard)))
                        ctx.webhookReply = true
                        updateTimeout(ctx)
                    }catch(e){console.log(e)}
                }
            }catch(e){}
        })

        item.action('show', async ctx => {
            try{    
                list(ctx, "–ü–æ–∫–∞–∑–∞—Ç—å")
            }catch(e){console.log(e)}
        })

        item.action('del', async ctx => {
            try{
                list(ctx, "–£–¥–∞–ª–∏—Ç—å")
            }catch(e){}
        })

        item.hears(/üìö/, async ctx => {
            require("./helper").menuMessage(ctx)  
        })

        item.action(/ques#/, async ctx => {
            try{
                if (ctx.update.callback_query.message.message_id === message.message_id){
                    if (ctx.update.callback_query.message.text.startsWith("–ü–æ–∫–∞–∑–∞—Ç—å")){
                        showQuestion(ctx)
                    }if (ctx.update.callback_query.message.text.startsWith("–£–¥–∞–ª–∏—Ç—å")){
                        deleteQuestion(ctx)
                    }
                    updateTimeout(ctx)
            }}catch(e){console.log(e)}
        })

        item.action('add', async ctx => {
            try{
                if (ctx.update.callback_query.message.message_id === message.message_id){
                    dictAdd[ctx.update.callback_query.message.text](ctx)       
                }
            }catch(e){console.log(e)}
        })

        item.action(/docs:/, async ctx => {
            try{
                if (ctx.update.callback_query.message.text.startsWith("–ü–æ–∫–∞–∑–∞—Ç—å")){
                    const i = +ctx.callbackQuery.data.substr(5)
                    await ctx.telegram.sendDocument(ctx.chat.id, docs[i].file_id)} 
                if (ctx.update.callback_query.message.text.startsWith("–£–¥–∞–ª–∏—Ç—å")){
                    deleteReport(ctx)
                }                
            }catch(e){console.log(e)}      
         })

        item.on('text', async ctx => {
            try{
                if (message.text.startsWith("‚ùî FAQ –î–æ–±–∞–≤–ª–µ–Ω–∏–µ")){
                    addFaq2(ctx)
                }
            }catch(e){
                ctx.reply('–®–∞–±–ª–æ–Ω –∑–∞–ø–æ–ª–Ω–µ–Ω –Ω–µ–≤–µ—Ä–Ω–æ')}
        })

        item.on('message', async ctx => {
            console.log('message')
            try{
                if (ctx.update.message.document){console.log('message')
                if (message.text.startsWith("üì¢ –û—Ç—á–µ—Ç—ã –ú–æ–∂–µ—Ç–µ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å")){
                    try{
                        console.log('message')
                        const tmp = {
                            file_name : ctx.update.message.document.file_name,
                            file_id : ctx.update.message.document.file_id
                        }
                        docs.push(tmp)
                        await fs.writeFileSync("data/documents.json", `${JSON.stringify(docs)}`);
                        await ctx.reply(`–§–∞–π–ª ${tmp.file_name} –ø–æ–ª—É—á–µ–Ω`)
                    }catch(e){console.log(e)}}
            }}catch(e){console.log(e)}
        })

        return item
    }
}

module.exports = new SceneGenerator().admin()

async function updateTimeout(ctx){
    if (timeout) clearTimeout(timeout)
    timeout = setTimeout(async () => {
        await ctx.telegram.deleteMessage(message.chat.id, message.message_id)
        await ctx.replyWithHTML('–í—ã—Ö–æ–¥ –∏–∑ —Ä–µ–∂–∏–º–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞...')
        require("./helper").menuMessage(ctx)
    }, 900000)
}

async function list(ctx, spec){
    if (ctx.update.callback_query.message.message_id === message.message_id){
        const text = ctx.update.callback_query.message.text
        await ctx.telegram.deleteMessage(message.chat.id, message.message_id)
        const scem = {text: spec + " "+ text}
        scem.keyboard = dictList[text](ctx)
        ctx.webhookReply = false
        message = await ctx.replyWithHTML(scem.text, Extra.HTML().markup(Markup.inlineKeyboard(scem.keyboard)))
        ctx.webhookReply = true
        updateTimeout(ctx)
        stack.push(scem)
    }
}

//////////////////////////

function listFAQ()
{
    let keyboard = []
    answers.values.forEach((item, i) => {
        keyboard.push([Markup.callbackButton(item.question[0], `ques#${item.id}`)])
    })
    keyboard.push([Markup.callbackButton('–®–∞–≥ –Ω–∞–∑–∞–¥', 'back')])
    return keyboard
}

async function addFAQ(ctx)
{
    await ctx.telegram.deleteMessage(message.chat.id, message.message_id)
    const scem = {text: "‚ùî FAQ –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞, —Å–∫–æ–ø–∏—Ä—É–π—Ç–µ —à–∞–±–ª–æ–Ω –≤–Ω–∏–∑—É –∏ –∑–∞–º–µ–Ω–∏—Ç–µ * –Ω–∞ —Å–æ–æ—Ç–≤—Å—Ç–≤—É—é—â–∏–π —Ç–µ–∫—Å—Ç", keyboard: [Markup.callbackButton('–û—Ç–º–µ–Ω–∏—Ç—å', 'back')]}
    ctx.webhookReply = false
    message = await ctx.replyWithHTML(scem.text, Extra.HTML().markup(Markup.inlineKeyboard(scem.keyboard)))
    ctx.webhookReply = true
    stack.push(scem)
    ctx.replyWithHTML(
`üá∑üá∫ –í–æ–ø—Ä–æ—Å:
*
üá∑üá∫ –û—Ç–≤–µ—Ç:
*
üá∫üá∏ Question:
*
üá∫üá∏ Answer:
*`)}

async function showQuestion(ctx){
    var id = +ctx.callbackQuery.data.split("#")[1]
    let element
    answers.values.forEach(item => {
        if (item.id == id){
            element = item
            return
        }
    })
    if (element){
        await ctx.replyWithHTML(`<b>üá∑üá∫ –í–æ–ø—Ä–æ—Å:</b> \n${element.question[0]}\n<b>üá∑üá∫ –û—Ç–≤–µ—Ç:</b> \n${element.answer[0]}\n\n<b>üá∫üá∏ Question:</b> \n${element.question[1]}\n<b>üá∫üá∏ Answer:</b> \n${element.answer[1]}\n`)
    }
}

async function deleteQuestion(ctx){
    var id = +ctx.callbackQuery.data.split("#")[1]
    console.log(id)
    answers.values = answers.values.filter(item =>{
        return item.id !== id
    })
    console.log(answers)
    await fs.writeFileSync("data/answers.json", `${JSON.stringify(answers)}`);
    await ctx.telegram.deleteMessage(message.chat.id, message.message_id)
    const scem = {text: "–≠–ª–µ–º–µ–Ω—Ç —É–¥–∞–ª–µ–Ω!", keyboard: [Markup.callbackButton('–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å', 'back')]}
    ctx.webhookReply = false
    message = await ctx.replyWithHTML(scem.text, Extra.HTML().markup(Markup.inlineKeyboard(scem.keyboard)))
    ctx.webhookReply = true
    stack.pop()
    stack.push(scem)
}

async function addFaq2(ctx){
    const element = {}
    element.question = []
    element.answer = []
    element.id = answers.values.length > 0 ? answers.values[answers.values.length - 1].id + 1 : 0
    let text = ctx.message.text.trim()

    let index = text.indexOf("üá∑üá∫ –í–æ–ø—Ä–æ—Å:")
    if (index === -1) throw Error()
    text = text.substr(index + 9)
    index = text.indexOf("üá∑üá∫ –û—Ç–≤–µ—Ç:")
    if (index === -1) throw Error()
    element.question[0] = text.substr(0, index - 1).trim()

    text = text.substr(index + 8)
    index = text.indexOf("üá∫üá∏ Question:")
    if (index === -1) throw Error()
    element.answer[0] = text.substr(0, index - 1).trim()

    text = text.substr(index + 11)
    index = text.indexOf("üá∫üá∏ Answer:")
    if (index === -1) throw Error()
    element.question[1] = text.substr(0, index - 1).trim()

    text = text.substr(index + 9)
    element.answer[1] = text.trim()
    answers.values.push(element)
    await ctx.telegram.deleteMessage(message.chat.id, message.message_id)
    await fs.writeFileSync("data/answers.json", `${JSON.stringify(answers)}`);
    const scem = {text: "–≠–ª–µ–º–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω!", keyboard: [Markup.callbackButton('–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å', 'back')]}
    ctx.webhookReply = false
    message = await ctx.replyWithHTML(scem.text, Extra.HTML().markup(Markup.inlineKeyboard(scem.keyboard)))
    ctx.webhookReply = true
    stack.pop()
    stack.push(scem)
}

//////////////////////////

async function addReport(ctx)
{
    await ctx.telegram.deleteMessage(message.chat.id, message.message_id)
    const scem = {text: "üì¢ –û—Ç—á–µ—Ç—ã –ú–æ–∂–µ—Ç–µ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç—ã, —É–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–æ–≤ —Å–æ–æ—Ç–≤–µ—Ç—Å–≤—É–µ—Ç —à–∞–±–ª–æ–Ω—É: [–ì—Ä—É–ø–ø–∞]-DD.MM.YY.[–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ]\n–ù–∞–ø—Ä–∏–º–µ—Ä 'IPO-29.08.2020.xlsx'\n –ù–∞–∑–≤–∞–Ω–∏—è –≥—Ä—É–ø–ø: –ê–∫—Ü–∏—è, IPO, –°–æ–≤–µ—Ç–Ω–∏–∫–∏", keyboard: [Markup.callbackButton('–ó–∞–∫–æ–Ω—á–∏—Ç—å', 'back')]}
    ctx.webhookReply = false
    message = await ctx.replyWithHTML(scem.text, Extra.HTML().markup(Markup.inlineKeyboard(scem.keyboard)))
    ctx.webhookReply = true
    stack.push(scem)
}

function listReports()
{
    try{
    console.log(docs)
    docs.sort((a, b) => a.file_name < b.file_name ? 1 : -1)
   
    let keyboard = []

    for (let i = 0; i < docs.length; i+=2){
        let mini = []
        let j = i + 1
        mini.push(Markup.callbackButton(`${docs[i].file_name}`, `docs:${i}`))
        while (j < docs.length && j < i + 2){
            mini.push(Markup.callbackButton(`${docs[j].file_name}`, `docs:${j}`))
            j++
        }
        keyboard[keyboard.length] = mini
    }
    keyboard.push([Markup.callbackButton('–®–∞–≥ –Ω–∞–∑–∞–¥', 'back')])
    return keyboard}catch(e){console.log(e)}
}

async function deleteReport(ctx){
    const i = +ctx.callbackQuery.data.substr(5)
    console.log(i)
    docs = docs.filter((element, index) => index !== i);
    await fs.writeFileSync("data/documents.json", `${JSON.stringify(docs)}`);
    await ctx.telegram.deleteMessage(message.chat.id, message.message_id)
    const scem = {text: "–≠–ª–µ–º–µ–Ω—Ç —É–¥–∞–ª–µ–Ω!", keyboard: [Markup.callbackButton('–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å', 'back')]}
    ctx.webhookReply = false
    message = await ctx.replyWithHTML(scem.text, Extra.HTML().markup(Markup.inlineKeyboard(scem.keyboard)))
    ctx.webhookReply = true
    stack.pop()
    stack.push(scem)
}
